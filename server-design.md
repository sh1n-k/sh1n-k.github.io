---
layout: default
title: 서버 설계 및 작업 계획
nav_order: 5
---

# 서버 설계 및 작업 계획

이 문서는 “조직별 메시지 업체 선택(CloudMsg/SendTalk)” 요구사항을 만족시키기 위한 서버 측 변경 계획이다. 핵심은 **발송 로직의 업체 의존성을 분리(Provider 추상화)**하고, **조직-업체 매핑과 인증정보를 운영자가 안전하게 관리**할 수 있도록 하는 것이다.

## **작업 단계(권장 순서)**

1. 데이터 모델/마이그레이션
- 조직-업체 매핑 테이블 신설
- 발송 이력 테이블 확장(업체 코드, 업체 메시지 ID, 결과 수신 시각 등)
- 기존 데이터 호환을 위해 기본값(CloudMsg) 또는 nullable 전략 적용

2. 내부 도메인 모델 정의
- 발송 요청/응답을 표현하는 내부 모델을 중립적으로 정의
- 전화번호는 내부 표준 포맷으로 정규화(권장: E.164)
- 알림톡 템플릿/변수/버튼 등을 “중립 필드”로 표현(Provider가 업체별 매핑)

3. Provider 추상화 계층 구현
- `MessageProvider` 인터페이스 정의(SMS/MMS/알림톡 발송)
- CloudMsgProvider, SendTalkProvider 구현
- **관리자 연결 테스트용 `validateCredentials()` 제공**(단, “발송”과 분리)

4. Provider 선택(Resolver) 구현
- 발송 시점에 조직 ID로 매핑 조회 → Provider 결정
- 매핑 없으면 CloudMsg 사용(하위 호환)
- 조회 성능을 위한 캐시 전략 도입(아래 기술 결정 사항 참고)

5. 기존 발송 서비스 리팩토링
- 기존 CloudMsg 직결 호출을 Provider 호출로 치환
- 발송 API의 외부 계약은 유지(클라이언트 변경 최소화)

6. Webhook 수신 및 상태 업데이트
- `/webhook/cloudmsg`, `/webhook/sendtalk`로 분리
- 업체별 서명 검증/페이로드 파싱 분리
- 공통 로직: 멱등 처리, 이력 상태 전이, 수신 시각 기록

7. 관리자용 관리 API 구현(관리자 화면 연동)
- 조직 목록/검색/페이징
- 조직별 현재 설정 조회
- 설정 생성/수정/삭제
- **연결 테스트 API**(입력값으로 검증 or 저장된 값으로 검증)
- 변경 이력(Audit Log) 기록 및 조회(선택이지만 강력 권장)

8. 테스트/검증/배포
- 단위 테스트: 매핑 변환, 번호 정규화, Provider 매핑
- 통합 테스트: 업체 API 호출(스테이징)
- 회귀 테스트: 기존 CloudMsg 조직의 발송 성공 보장
- 단계적 롤아웃: 매핑 미설정 상태로 먼저 배포 → 테스트 조직부터 전환

## **기술적 결정 사항(선택 근거 포함)**

1. Provider 인터페이스 형태
- 선택지 A: `send(MessageRequest)` 단일 메서드 + type 분기
- 선택지 B: `sendSms()`, `sendMms()`, `sendAlimtalk()` 타입별 메서드
- 권장: **B**
  - 이유: 관리자/운영 관점에서 명시적이며, SendTalk처럼 엔드포인트가 분리된 구조에 자연스럽다.
  - CloudMsg는 내부에서 통합 엔드포인트로 묶어 호출하면 된다(구현체 내부 책임).

2. 내부 도메인 모델(superset) 범위
- 권장: **superset + Optional 필드**
  - 이유: 업체별로 존재하는 필드가 다르므로, 공통 최소만 두면 기능이 “낮은 쪽”으로 끌려간다.
  - 단, “특정 업체 전용 기능”은 과제 범위를 넘어갈 수 있으니, 지금은 핵심 필드 중심으로 제한한다(버튼 타입 등은 테스트로 안전장치).

3. 인증정보 저장 스키마(JSON vs 컬럼 분리)
- 선택지 A: JSON 단일 컬럼(업체별 key-value)
- 선택지 B: 업체별 필드 컬럼(AccessKey/SecretKey 등)
- 권장: **A(JSON)**
  - 이유: 업체 추가/변경에 유연하고, UI도 “업체별 폼”과 자연스럽게 매칭된다.
  - 단점(쿼리/인덱싱 어려움)은 관리 화면 중심 사용이라 크게 문제가 되지 않는다.
  - 보안상 JSON이라도 암호화(전체 블롭 암호화 또는 필드 암호화)는 동일하게 적용 가능.

4. 캐싱 전략(매핑 조회)
- 목표: 발송 트래픽에서 매 요청 DB 조회를 피한다.
- 권장: **TTL 기반 캐시 + 변경 시 즉시 무효화**
  - 로컬 캐시(인스턴스별) 또는 Redis(분산) 중 선택
  - 관리 API에서 설정 변경 시 해당 조직 캐시를 즉시 invalidate
  - TTL은 “혹시 invalidate 누락” 대비 안전망

5. Webhook 멱등 처리
- Webhook은 재전송/중복이 흔하다.
- 권장: **업체 messageId + status + timestamp(가능하면)로 idempotency key 구성**
  - 이미 처리한 이벤트면 no-op 처리
  - 이력 상태 전이는 “허용되는 전이만” 업데이트(예: QUEUED → SENT/FAILED)

6. 트랜잭션 경계
- 외부 API 호출은 DB 트랜잭션에 포함하지 않는다.
- 권장 흐름:
  - 이력 생성(REQUESTED/QUEUED) → 커밋
  - Provider 호출
  - 즉시 실패면 이력 FAILED로 업데이트(또는 별도 에러 기록)
  - 최종 성공/실패는 Webhook으로 업데이트

7. 관리자 연결 테스트 API의 의미
- 연결 테스트는 “발송 성공”이 아니라 **인증정보가 유효하고 최소 API 호출이 가능한지** 확인하는 용도다.
- 테스트가 업체 장애로 실패할 수 있으므로:
  - 기본 정책: 테스트 성공 후 저장 허용
  - 예외 정책(선택): 슈퍼어드민만 “강제 저장(테스트 생략)” 가능하게 하되, Audit Log에 강제 플래그 남김

## **리스크 및 대응**

1. 변환 로직 오류(필드 누락/오매핑)
- 대응: Provider 매핑 단위 테스트 + 샘플 페이로드 기반 통합 테스트
- 특히 알림톡 버튼/변수 매핑은 케이스가 많아 누락 위험이 크다.

2. 기존 기능 회귀
- 대응: 리팩토링 전에 기존 발송 플로우를 테스트로 “명세화”
- 초기 배포는 매핑 미설정(=CloudMsg) 상태로 운영해 회귀를 빠르게 탐지

3. Webhook 유실/지연으로 상태 불일치
- 대응: “장시간 QUEUED” 이력에 대한 보정 수단
  - 가능하면 업체 결과 조회 API 기반 배치 동기화(있다면)
  - 없다면 운영 경보/리포트로 수동 추적 가능하게 로그 강화

4. 인증정보 노출
- 대응: DB 암호화 + 조회 시 마스킹 + 권한 분리(운영자라도 원문 조회 불가)
- Audit Log에 인증정보 원문을 남기지 않는다(변경 여부만 기록)

5. 운영자 실수로 인한 장애
- 대응: 연결 테스트/확인 모달/변경 이력/낙관적 락
- 삭제는 “조직명 재입력” 같은 하드 가드 적용

6. 동시 수정 충돌
- 대응: optimistic locking(version 컬럼) 적용
- 충돌 시 “최신 데이터 재조회” 안내

---
